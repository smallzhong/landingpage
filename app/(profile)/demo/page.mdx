BSc in Computer Science @ Shanghai Jiao Tong University :it[(2019 - present)]

Generally interested in PL concepts and techniques that helps people build *correct* and *efficient* software, especially in a correct-by-construction way. I mainly worked on deductive verification and compiler correctness, and also did some work on DSL design and synthesis.

And now, I'm interested in:
- Composable and expressive *semantics* (e.g. [Interaction Trees](https://dl.acm.org/doi/10.1145/3371119))
- Interesting *language features* like staging and effect systems
- Beautiful and practical *type theory and systems* (e.g. row polymorphism, gradual typing, session types, etc.)
- Stuff that might rescue us from tedious proof engineering (e.g. proof synthesis and [better HCI](https://hazel.org/))

### On-going Projects

1. Optimizing Compiler for ZK Circuits\
:it[advised by [Prof. Yu Feng](https://fredfeng.github.io/) at [CS@UCSB](https://www.cs.ucsb.edu/)]
2. Verification-aided Source Code Optimization\
:it[advised by [Prof. Qinxiang Cao](https://jhc.sjtu.edu.cn/people/members/faculty/qinxiang-cao.html) at [JHC@SJTU](https://jhc.sjtu.edu.cn/)]

### Misc

#### Coding Languages

My personal views on languages I've used (or not). I ordered them casually,

1. **OCaml** - An impressive [~~higher-order imperative~~](https://discuss.ocaml.org/t/why-are-monads-important/8868/4) language that's at a sweet spot between expressiveness and practicality. I'm still not used to its module system and untyped effects, but I do enjoy the experience of writing OCaml code.
2. **Coq** - The go-to proof assistant for me. Good ecosystem and community, and I'm also a fan of tactics. But things can get really messy when it comes to Ltac and dependent types. One day I might try out Lean. Sorry, Coq xD
3. **Rust** - Finally, an industrial language with ADT, typeclass(-like stuff), affine types, and a core team that REALLY cares about soundness! Was my first choice for hobby projects before I met OCaml.
4. **Python** - I still use it for quick prototyping and data analysis. Be hold the evil power of monkey and duck stuff!
5. **Haskell** - It traumatized my friend with endless monad transformers and chrome-like HLS (in terms of memory usage), so I haven't tried it yet. But hey, who can resist the temptation of purity and laziness? Going to try it out. Please pray for my mental health.
6. **C++** - Meh. Hard to learn, hard to use, hard to debug. Not my cup of tea.
7. **Go** - It has a good runtime and really impressive compilation speed. That's all the good things I can say about it.
8. **HTML/CSS/JS** - I use them each time I need to update my website or write a GUI.
9. **Visual Basic** - My first programming language. Look! It has effect handlers! (Just kidding. I'm not sure whether "err: Resume Next"s are true effect handlers.)

